/* This file is part of COVISE.

   You can use it under the terms of the GNU Lesser General Public License
   version 2.1 or later, see lgpl-2.1.txt.

 * License: LGPL 2+ */

/* mod_gen Version 1                                                     */
/* Module Name: "ucd FLE" (Filter) (Subroutine)              */
/* Author:Filip Sadlo                                                    */
/* Date Created: Fri Jul 14 23:40:00 2006                                */
/*                                                                       */
/* This file is automatically generated by the Module Generator (mod_gen)*/
/* Please do not modify or move the contents of this comment block as    */
/* mod_gen needs it in order to read module sources back in.             */
/*                                                                       */
/* input 0 "surface" geom REQUIRED                                       */
/* input 1 "ucd" ucd REQUIRED                                            */
/* input 2 "pick information" struct upstream_geom REQUIRED              */
/* output 0 "orth curve" field 1D 3-space 1-vector irregular float     */
/* param 0 "quantity" radio_buttons "helicity" "helicity:vorticity mag:lambda2" ":"*/
/* End of Module Description Comments                                    */
// #### to do: adapt definitions above

#include <stdio.h>
#include <avs/avs.h>
#include <avs/port.h>
#include <avs/ucd_defs.h>
#include <avs/geom.h>

/* ----> START OF USER-SUPPLIED CODE SECTION #1 (INCLUDE FILES, GLOBAL VARIABLES)*/

#include <math.h>
#include <vector>
#include <values.h>
#include <libgen.h>
#include "linalg.h"
#include "avs_ext.h"
#include "unstructured.h"
#include "dataDict.h"
#include "unisys.h"

static Unstructured *unst = NULL;

// DELETEME
//#define OUTCOMP_FTLE      0
//#define OUTCOMP_EVAL_MAX  1
//#define OUTCOMP_EVAL_MED  2
//#define OUTCOMP_EVAL_MIN  3
//#define OUTCOMP_TIME      4

#include "FLE_impl.cpp" // #### including .cpp

#define MO_SEP ":"
#define MO_FTLE "FTLE"
#define MO_FLLE "FLLE"
#define MO_FSLE "FSLE"
#define MO_FMLE "FMLE"
#define MO_FALE "FALE"
#define MO_ALL MO_FTLE MO_SEP MO_FLLE MO_SEP MO_FSLE MO_SEP MO_FMLE MO_SEP MO_FALE

char *picked_obj;

/* <---- END OF USER-SUPPLIED CODE SECTION #1                            */

/* *****************************************/
/*  Module Description                     */
/* *****************************************/
int ucd_FLE_desc()
{

    int in_port, out_port, param;
    extern int ucd_FLE_compute(UCD_structure * ucd, UCD_structure * grid, UCD_structure * *ucd_out, AVSfield_float * *trajectories,
                               float *origin_x, float *origin_y, float *origin_z,
                               int cells_x, int cells_y, int cells_z,
                               float *cell_size,
                               char *velocity,
                               int unsteady,
                               char *velocity_file,
                               float *start_time,
                               // int crop_ucd, int dim_x, int dim_y, int dim_z, float *origin_x, float *origin_y, float *origin_z, float *voxel_size,
                               char *mode,
                               int ln,
                               int divT,
                               float *integration_time,
                               float *integration_length,
                               int time_intervals,
                               float *sep_factor_min,
                               int integ_steps_max, int forward,
                               int smoothing_range,
                               int omit_boundary_cells,
                               int grad_neigh_disabled,
                               int execute);

    AVSset_module_name("ucd FLE", MODULE_FILTER);

    /* Input Port Specifications               */
    in_port = AVScreate_input_port("ucd", "ucd", REQUIRED);
    in_port = AVScreate_input_port("grid", "ucd", OPTIONAL);

    /* Output Port Specifications              */
    out_port = AVScreate_output_port("ucd out", "ucd");
    out_port = AVScreate_output_port("trajectories",
                                     "field 2D 3-space 2-vector irregular float");

    /* Parameter Specifications                */
    param = AVSadd_float_parameter("origin x", 0.0, FLOAT_UNBOUND, FLOAT_UNBOUND);
    AVSconnect_widget(param, "typein_real");

    param = AVSadd_float_parameter("origin y", 0.0, FLOAT_UNBOUND, FLOAT_UNBOUND);
    AVSconnect_widget(param, "typein_real");

    param = AVSadd_float_parameter("origin z", 0.0, FLOAT_UNBOUND, FLOAT_UNBOUND);
    AVSconnect_widget(param, "typein_real");

    param = AVSadd_parameter("cells x", "integer", 10, 1, INT_MAX);
    AVSconnect_widget(param, "typein_integer");

    param = AVSadd_parameter("cells y", "integer", 10, 1, INT_MAX);
    AVSconnect_widget(param, "typein_integer");

    param = AVSadd_parameter("cells z", "integer", 10, 1, INT_MAX);
    AVSconnect_widget(param, "typein_integer");

    param = AVSadd_float_parameter("cell size", 0.01, 0.0, FLOAT_UNBOUND);
    AVSconnect_widget(param, "typein_real");

    param = AVSadd_parameter("velocity", "choice", "", "", ":");
    AVSconnect_widget(param, "choice_browser");

    param = AVSadd_parameter("unsteady", "boolean", 0, 0, 1);
    AVSconnect_widget(param, "toggle");

    param = AVSadd_parameter("velocity file", "string", "", "", ":");
    AVSconnect_widget(param, "browser");

    param = AVSadd_float_parameter("start time", 0.0, FLOAT_UNBOUND, FLOAT_UNBOUND);
    AVSconnect_widget(param, "typein_real");

    /*
        param = AVSadd_parameter("crop ucd", "boolean", 0, 0, 1);
        AVSconnect_widget(param, "toggle");

        param = AVSadd_parameter("dim x", "integer", 10, 1, INT_MAX);
        AVSconnect_widget(param, "typein_integer");
        param = AVSadd_parameter("dim y", "integer", 10, 1, INT_MAX);
        AVSconnect_widget(param, "typein_integer");
        param = AVSadd_parameter("dim z", "integer", 10, 1, INT_MAX);
        AVSconnect_widget(param, "typein_integer");

        param = AVSadd_float_parameter("origin x", 0.0, FLOAT_UNBOUND, FLOAT_UNBOUND);
        AVSconnect_widget(param, "typein_real");
        param = AVSadd_float_parameter("origin y", 0.0, FLOAT_UNBOUND, FLOAT_UNBOUND);
        AVSconnect_widget(param, "typein_real");
        param = AVSadd_float_parameter("origin z", 0.0, FLOAT_UNBOUND, FLOAT_UNBOUND);
        AVSconnect_widget(param, "typein_real");
           
        param = AVSadd_float_parameter("voxel size", 0.1, 0.0, FLOAT_UNBOUND);
        AVSconnect_widget(param, "typein_real");
        */

    param = AVSadd_parameter("mode", "choice", MO_FTLE, MO_ALL, MO_SEP);
    AVSconnect_widget(param, "radio_buttons");

    param = AVSadd_parameter("ln", "boolean", 1, 0, 1);
    AVSconnect_widget(param, "toggle");

    param = AVSadd_parameter("/T", "boolean", 1, 0, 1);
    AVSconnect_widget(param, "toggle");

    // per time interval
    param = AVSadd_float_parameter("integration time", 0.1, 0.0, FLOAT_UNBOUND);
    AVSconnect_widget(param, "typein_real");

    // per time interval
    param = AVSadd_float_parameter("integration length", 0.1, 0.0, FLOAT_UNBOUND);
    //AVSadd_parameter_prop(param,"layout","string_block",
    //	      "manipulator \"$Module:integration length\" -hide");
    AVSconnect_widget(param, "typein_real");

    param = AVSadd_parameter("time intervals", "integer", 50, 1, INT_MAX);
    AVSconnect_widget(param, "typein_integer");

    param = AVSadd_float_parameter("sep factor min", 1.1, 1.0, FLOAT_UNBOUND);
    AVSconnect_widget(param, "typein_real");

    // per time interval
    param = AVSadd_parameter("integ steps max", "integer", 100, 1, INT_MAX);
    AVSconnect_widget(param, "typein_integer");

    param = AVSadd_parameter("forward", "boolean", 1, 0, 1);
    AVSconnect_widget(param, "toggle");

    param = AVSadd_parameter("smoothing range", "integer", 1, 1, INT_MAX);
    AVSconnect_widget(param, "typein_integer");

    param = AVSadd_parameter("omit boundary cells", "boolean", 0, 0, 1);
    AVSconnect_widget(param, "toggle");

    param = AVSadd_parameter("grad neigh disabled", "boolean", 1, 0, 1);
    AVSconnect_widget(param, "toggle");

    param = AVSadd_parameter("execute", "boolean", 1, 0, 1);
    AVSconnect_widget(param, "toggle");

    /* compute routine                         */
    AVSset_compute_proc((int (*)())ucd_FLE_compute);

    /* ----> START OF USER-SUPPLIED CODE SECTION #2 (ADDITIONAL SPECIFICATION INFO)*/
    /* <---- END OF USER-SUPPLIED CODE SECTION #2                            */
    return (1);
}

/* *****************************************/
/* Module Compute Routine                  */
/* *****************************************/
int ucd_FLE_compute(UCD_structure *ucd, UCD_structure *grid, UCD_structure **ucd_out, AVSfield_float **trajectories,
                    float *origin_x, float *origin_y, float *origin_z,
                    int cells_x, int cells_y, int cells_z,
                    float *cell_size,
                    char *velocity,
                    int unsteady,
                    char *velocity_file,
                    float *start_time,
                    //int crop_ucd, int dim_x, int dim_y, int dim_z, float *origin_x, float *origin_y, float *origin_z, float *voxel_size,
                    char *mode, int ln, int divT,
                    float *integration_time, float *integration_length,
                    int time_intervals, float *sep_factor_min,
                    int integ_steps_max, int forward, int smoothing_range,
                    int omit_boundary_cells,
                    int grad_neigh_disabled,
                    int execute)
{

    /* ----> START OF USER-SUPPLIED CODE SECTION #3 (COMPUTE ROUTINE BODY)   */

    // system wrapper
    UniSys us;

    if (ucd_findNodeCompByVeclen(ucd, 3, 0) < 0)
    {
        us.error("UCD must contain at least one 3-vect component");
        return 0;
    }

    if (unsteady && ucd_nodeCompNb(ucd) > 1)
    {
        us.warning("transient mode requires that the number of UCD components matches those in the transient file(s)");
        //return 0;
    }

    //if (AVSparameter_changed("mode")) {
    {
        char *cp1, *cp2;

        if (AVSinput_changed("grid", 0))
        {
            if (grid)
            {
                AVScommand("kernel", "manipulator \"$Module:origin x\" -hide", &cp1, &cp2);
                AVScommand("kernel", "manipulator \"$Module:origin y\" -hide", &cp1, &cp2);
                AVScommand("kernel", "manipulator \"$Module:origin z\" -hide", &cp1, &cp2);
                AVScommand("kernel", "manipulator \"$Module:cells x\" -hide", &cp1, &cp2);
                AVScommand("kernel", "manipulator \"$Module:cells y\" -hide", &cp1, &cp2);
                AVScommand("kernel", "manipulator \"$Module:cells z\" -hide", &cp1, &cp2);
                AVScommand("kernel", "manipulator \"$Module:cell size\" -hide", &cp1, &cp2);
            }
            else
            {
                AVScommand("kernel", "manipulator \"$Module:origin x\" -show", &cp1, &cp2);
                AVScommand("kernel", "manipulator \"$Module:origin y\" -show", &cp1, &cp2);
                AVScommand("kernel", "manipulator \"$Module:origin z\" -show", &cp1, &cp2);
                AVScommand("kernel", "manipulator \"$Module:cells x\" -show", &cp1, &cp2);
                AVScommand("kernel", "manipulator \"$Module:cells y\" -show", &cp1, &cp2);
                AVScommand("kernel", "manipulator \"$Module:cells z\" -show", &cp1, &cp2);
                AVScommand("kernel", "manipulator \"$Module:cell size\" -show", &cp1, &cp2);
            }
        }

        if (AVSparameter_changed("unsteady"))
        {
            if (unsteady)
            {
                AVScommand("kernel", "manipulator \"$Module:velocity file\" -show", &cp1, &cp2);
                AVScommand("kernel", "manipulator \"$Module:start time\" -show", &cp1, &cp2);
            }
            else
            {
                AVScommand("kernel", "manipulator \"$Module:velocity file\" -hide", &cp1, &cp2);
                AVScommand("kernel", "manipulator \"$Module:start time\" -hide", &cp1, &cp2);
            }
        }

        if (AVSparameter_changed("mode"))
        {
            if (strcmp(mode, MO_FTLE) == 0)
            {
                AVScommand("kernel", "manipulator \"$Module:ln\" -show", &cp1, &cp2);
                AVScommand("kernel", "manipulator \"$Module:/T\" -show", &cp1, &cp2);
                AVScommand("kernel", "manipulator \"$Module:integration time\" -show", &cp1, &cp2);
                AVScommand("kernel", "manipulator \"$Module:integration length\" -hide", &cp1, &cp2);
                AVScommand("kernel", "manipulator \"$Module:sep factor min\" -hide", &cp1, &cp2);
                AVScommand("kernel", "manipulator \"$Module:time intervals\" -hide", &cp1, &cp2);
            }
            else if (strcmp(mode, MO_FLLE) == 0)
            {
                AVScommand("kernel", "manipulator \"$Module:ln\" -show", &cp1, &cp2);
                AVScommand("kernel", "manipulator \"$Module:/T\" -show", &cp1, &cp2);
                AVScommand("kernel", "manipulator \"$Module:integration time\" -hide", &cp1, &cp2);
                AVScommand("kernel", "manipulator \"$Module:integration length\" -show", &cp1, &cp2);
                AVScommand("kernel", "manipulator \"$Module:sep factor min\" -hide", &cp1, &cp2);
                AVScommand("kernel", "manipulator \"$Module:time intervals\" -hide", &cp1, &cp2);
            }
            else if (strcmp(mode, MO_FSLE) == 0)
            {
                AVScommand("kernel", "manipulator \"$Module:ln\" -show", &cp1, &cp2);
                AVScommand("kernel", "manipulator \"$Module:/T\" -show", &cp1, &cp2);
                AVScommand("kernel", "manipulator \"$Module:integration time\" -show", &cp1, &cp2);
                AVScommand("kernel", "manipulator \"$Module:integration length\" -hide", &cp1, &cp2);
                AVScommand("kernel", "manipulator \"$Module:sep factor min\" -show", &cp1, &cp2);
                AVScommand("kernel", "manipulator \"$Module:time intervals\" -show", &cp1, &cp2);
            }
            else if ((strcmp(mode, MO_FMLE) == 0) || (strcmp(mode, MO_FALE) == 0))
            {
                AVScommand("kernel", "manipulator \"$Module:ln\" -show", &cp1, &cp2);
                AVScommand("kernel", "manipulator \"$Module:/T\" -show", &cp1, &cp2);
                AVScommand("kernel", "manipulator \"$Module:integration time\" -show", &cp1, &cp2);
                AVScommand("kernel", "manipulator \"$Module:integration length\" -hide", &cp1, &cp2);
                AVScommand("kernel", "manipulator \"$Module:sep factor min\" -hide", &cp1, &cp2);
                AVScommand("kernel", "manipulator \"$Module:time intervals\" -show", &cp1, &cp2);
            }
        }
    }

    if (unsteady && (strcmp(mode, MO_FLLE) == 0))
        us.warning("FLLE makes no sense for transient data (\"nearby trajectories are not nearby\") !!");

    if (*integration_time <= 0.0)
    {
        us.error("integration time must be larger than zero");
        return 0;
    }

    // input wrapper
    if (AVSinput_changed("ucd", 0))
    {
        if (unst)
            delete unst;
        unst = new Unstructured(ucd);
    }

    // process component choice selection
    int compVelo = ucd_processCompChoice(ucd, "ucd", velocity, "velocity", 3,
                                         unst->getVectorNodeDataComponent());
    if (compVelo >= 0)
        unst->selectVectorNodeData(compVelo);

    // init

    /* Allocate output UCD */
    if (*ucd_out && *ucd_out != ucd)
        UCDstructure_free(*ucd_out);
    UCD_structure *ucd1 = NULL;
    char *labels;
    if (strcmp(mode, MO_FTLE) == 0)
        labels = ucdOut_labelsFTLE;
    else if (strcmp(mode, MO_FLLE) == 0)
        labels = ucdOut_labelsFLLE;
    else if (strcmp(mode, MO_FSLE) == 0)
        labels = ucdOut_labelsFSLE;
    else if (strcmp(mode, MO_FMLE) == 0)
        labels = ucdOut_labelsFMLE;
    else
        labels = ucdOut_labelsFALE;
    if (grid)
    {
#if 0
    ucd1 = ucdClone(grid, 1, "ucd out");
#else
#if 0 // DELETEME
    if (strcmp(mode, MO_FTLE) == 0)
      ucd1 = ucdClone(grid, ucdOut_compNb, ucdOut_components, "ucd out", ucdOut_labelsFTLE, ucdOut_delim);
    else if (strcmp(mode, MO_FLLE) == 0)
      ucd1 = ucdClone(grid, ucdOut_compNb, ucdOut_components, "ucd out", ucdOut_labelsFLLE, ucdOut_delim);
    else if (strcmp(mode, MO_FSLE) == 0)
      ucd1 = ucdClone(grid, ucdOut_compNb, ucdOut_components, "ucd out", ucdOut_labelsFSLE, ucdOut_delim);
    else if (strcmp(mode, MO_FMLE) == 0)
      ucd1 = ucdClone(grid, ucdOut_compNb, ucdOut_components, "ucd out", ucdOut_labelsFMLE, ucdOut_delim);
    else
      ucd1 = ucdClone(grid, ucdOut_compNb, ucdOut_components, "ucd out", ucdOut_labelsFALE, ucdOut_delim);
#endif
        ucd1 = ucdClone(grid, ucdOut_compNb, ucdOut_components, "ucd out", labels, ucdOut_delim);
#endif
    }
    else
    {
        ucd1 = generateUniformUCD("ucd out", *origin_x, *origin_y, *origin_z,
                                  cells_x, cells_y, cells_z,
                                  *cell_size,
                                  ucdOut_compNb, ucdOut_components,
                                  labels, ucdOut_delim);
    }
    *ucd_out = ucd1;

    // unstructured wrapper for output
    Unstructured *unst_out = new Unstructured(*ucd_out);

    // allocate field for trajectories
    if (*trajectories)
        AVSfield_free((AVSfield *)*trajectories);
    int dims[2];
    dims[0] = integ_steps_max + 1;
    dims[1] = ucd1->nnodes;
    *trajectories = (AVSfield_float *)AVSdata_alloc("field 2D 2-vector irregular 3-space float", dims);
    if (*trajectories == NULL)
    {
        AVSerror("allocation failed");
        return (0);
    }

    // field wrapper for output
    UniField *unif_traj = new UniField((AVSfield *)*trajectories);

    // compute
    if (execute)
        FLE_impl(&us, unst, compVelo, unsteady, velocity_file, *start_time,
                 //crop_ucd, *origin_x, *origin_y, *origin_z, *voxel_size,
                 //mode,
                 AVSchoice_number("mode", mode),
                 ln, divT,
                 *integration_time, *integration_length,
                 time_intervals, *sep_factor_min, integ_steps_max, forward,
                 unst_out, smoothing_range,
                 omit_boundary_cells, grad_neigh_disabled, unif_traj);

    // delete unstructured wrapper for output (but not the field)
    delete unst_out;

    // delete field wrapper (but not the field)
    delete unif_traj;

    /* <---- END OF USER-SUPPLIED CODE SECTION #3              */
    return (1);
}

/* ***********************************************************************/
/* Initialization for modules contained in this file.                    */
/* ***********************************************************************/
static int((*mod_list[])()) = {
    ucd_FLE_desc
};
#define NMODS (sizeof(mod_list) / sizeof(char *))

#ifdef __cplusplus
extern "C" // Add for C++
    {
#endif

void AVSinit_modules()
{ // Modify for C++
    AVSinit_from_module_list(mod_list, NMODS);
}

#ifdef __cplusplus
} // Add for C++
#endif

/* ----> START OF USER-SUPPLIED CODE SECTION #4 (SUBROUTINES, FUNCTIONS, UTILITY ROUTINES)*/

/* <---- END OF USER-SUPPLIED CODE SECTION #4                            */
